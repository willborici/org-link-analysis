Fix the following function to refactor code in main.py that draw directed/ undirected edges:

# NB: networkx doesn't like it when arrows=False for undirected graphs -- just remove it
# to cancel the warning -- not ideal, but a couple of ifs on draw_arrow should do the trick
def draw_edge(graf, layout, nr_edges, edge_lbl, draw_arrow):
    # given a graph and its layout (pos), draw for directed (draw_arrow = True) or undirected
    if nr_edges == 1:
        graph.draw_networkx_edges(graf, layout, edgelist=[(u, v, key)],
                                  style='solid',
                                  edge_color='gray', width=d['weight'], arrows=draw_arrow)
        # Single edge, place label at midpoint
        label_x = (pos[u][0] + pos[v][0]) / 2
        label_y = (pos[u][1] + pos[v][1]) / 2
        plt.text(label_x, label_y, edge_lbl, fontsize=10, fontweight='bold', color='black', ha='center',
                 va='center')
    else:
        # Multiple edges between u and v, draw with offset
        offset = 0.1  # Offset for edge position

        # Determine angle between nodes u and v
        dx, dy = pos[v][0] - pos[u][0], pos[v][1] - pos[u][1]
        angle = np.arctan2(dy, dx)

        # Distribute edges around the angle
        distances = np.linspace(-0.2, 0.2, nr_edges)
        for i, distance in enumerate(distances):
            sx = pos[u][0] + distance * np.sin(angle + np.pi / 2)
            sy = pos[u][1] - distance * np.cos(angle + np.pi / 2)
            tx = pos[v][0] + distance * np.sin(angle + np.pi / 2)
            ty = pos[v][1] - distance * np.cos(angle + np.pi / 2)

            graph.draw_networkx_edges(graf, layout, edgelist=[(u, v)], width=d['weight'],
                                      edge_color='gray',
                                      connectionstyle=f"arc3,rad={0.1 + (i * 0.5)}", arrows=draw_arrow)
            # Place edge label
            label_x = (sx + tx) / 2
            label_y = (sy + ty) / 2
            plt.text(label_x, label_y, edge_lbl, fontsize=10, fontweight='bold', color='black',
                     ha='center',
                     va='center')


for u, v, key, d in mixed_graph.edges(data=True, keys=True):
    draw_edge(mixed_graph, pos, mixed_graph.number_of_edges(u, v), d['relationship'], d.get('directed'))
